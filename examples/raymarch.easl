@{group 0
  binding 0
  address uniform}
(var dimensions: vec2f)

@{group 0
  binding 1
  address uniform}
(var time: f32)

(def triangles: u32
     1)

(defn uni->bi [x: vec2f]: vec2f
  (-> x (* 2.) (- 1.)))

@vertex
(defn vertex [@builtin vertex-index: u32]: vec4f
  (vec4f (match vertex-index
           0 (vec2f -1.)
           1 (vec2f -1. 3.)
           _ (vec2f 3. -1.))
         0.
         1.))

(enum (Option T)
  None
  (Some T))

(struct Ray
  pos: vec3f
  dir: vec3f)

(defn advance [r: Ray
               d: f32]: Ray
  (Ray (+ r.pos (* d r.dir)) r.dir))

(defn gradient [f: (Fn [vec3f] f32)
                x: vec3f]: vec3f
  (- (vec3f (f (+ x (vec3f 0.001 0. 0.)))
            (f (+ x (vec3f 0. 0.001 0.)))
            (f (+ x (vec3f 0. 0. 0.001))))
     (f x)))

(defn raymarch [sdf: (Fn [vec3f] f32)
                ray: Ray]: (Option vec3f)
  (let [@var current-dist 0.]
    (for [i 0 (< i 256) (= i (+ i 1))]
      (let [current-pos (.pos (advance ray current-dist))
            dist (sdf current-pos)]
        (when (< (abs dist) 0.001)
          (return (Some (normalize (gradient sdf current-pos)))))
        (when (> dist 5.)
          (break))
        (+= current-dist (* 0.9 dist))))
    None))

(defn sd-box [pos: vec3f
              size: vec3f]: f32
  (let [q (- (abs pos) size)]
    (+ (length (max q (vec3f 0.)))
       (min (max q.x q.y q.z) 0.))))

(defn rot [angle: f32]: mat2x2f
  (let [c (cos angle)
        s (sin angle)]
    (mat2x2f c (- s) s c)))

(defn sd-scene [@var pos: vec3f]: f32
  (-= pos (vec3f 0. 0. 2.5))
  (= pos.zy
     (* pos.zy
        (rot (* 0.4 (+ time 2.)))))
  (= pos.xz
     (* pos.xz
        (rot (* -0.7 (+ time 1.)))))
  (+ (sd-box pos (vec3f 0.75))
     (* 0.025
        (cos (+ (* 11. pos.x) (* 4.5 time))))
     (* 0.01
        (cos (+ 2. (* 4. pos.y) (* 2. time))))
     (* 0.03
        (cos (+ 5. (* 7. pos.z) (* 6.25 time))))))

@fragment
(defn fragment [@builtin position: vec4f]: vec4f
  (let [screen-pos (-> position
                       .xy
                       (/ dimensions)
                       uni->bi
                       (* (/ dimensions
                             (min dimensions.x dimensions.y))))
        surface-normal (raymarch sd-scene
                                 (Ray (vec3f 0.)
                                      (normalize (vec3f screen-pos 1.))))]
    (match surface-normal
      (Some normal) (vec4f (pow (* (+ normal 1.) 0.5)
                                (vec3f 2.2))
                           1.)
      None (vec4f (vec3f 0.) 1.))))
